/**
 * Mermaid Initialization and Rendering Module
 * 
 * Handles the configuration and rendering of Mermaid diagrams.
 * Designed to work with the dynamic navigation system.
 */

(function () {
    'use strict';

    // Configuration
    const MERMAID_CONFIG = {
        startOnLoad: false,
        theme: 'default', // Default base config
        securityLevel: 'loose',
        flowchart: {
            useMaxWidth: true,
            htmlLabels: true
        }
    };

    let isInitialized = false;

    // Initialize Mermaid
    function init(theme = 'light') {
        if (window.mermaid) {
            // Map 'light' to 'default' to preserve original look while using semantic naming
            const configTheme = theme === 'light' ? 'default' : theme;
            window.mermaid.initialize({ ...MERMAID_CONFIG, theme: configTheme });
            isInitialized = true;
            console.log(`Mermaid initialized with theme: ${theme}`);
        } else {
            console.warn('Mermaid library not found');
        }
    }

    // Get current theme based on HTML class
    function getCurrentTheme() {
        const isDark = document.documentElement.classList.contains('dark');
        return isDark ? 'dark' : 'light';
    }

    /**
     * Renders all mermaid diagrams in the current document.
     * Looks for <pre><code class="language-mermaid"> blocks generated by marked.js
     * and converts them to <div class="mermaid"> blocks for processing.
     */
    async function renderMermaid() {
        if (!window.mermaid) return;

        const theme = getCurrentTheme();
        init(theme);

        // Find all mermaid code blocks
        const codeBlocks = document.querySelectorAll('pre code.language-mermaid');
        if (codeBlocks.length === 0) return;

        console.log(`Found ${codeBlocks.length} mermaid diagrams to render`);

        // Convert key elements
        const nodesToProcess = [];

        codeBlocks.forEach((codeBlock, index) => {
            // Check if already processed (though markup should be fresh from navigation)
            if (codeBlock.parentElement.tagName !== 'PRE') return;

            const preElement = codeBlock.parentElement;
            const rawMermaidCode = codeBlock.textContent;

            // Create a replacement div
            const div = document.createElement('div');
            div.className = 'mermaid';
            div.textContent = rawMermaidCode;

            // Store original source for re-rendering on theme change
            div.setAttribute('data-original-code', rawMermaidCode);

            // Replace the pre element
            preElement.replaceWith(div);
            nodesToProcess.push(div);
        });

        // Run mermaid on the new divs
        try {
            await window.mermaid.run({
                nodes: nodesToProcess
            });
        } catch (error) {
            console.error('Mermaid rendering failed:', error);
        }
    }

    // Re-render existing diagrams when theme changes
    async function updateDiagramsTheme() {
        if (!window.mermaid) return;

        const theme = getCurrentTheme();
        console.log(`Theme changed to ${theme}, re-rendering Mermaid diagrams...`);

        // Re-init with new theme
        init(theme);

        // Find all existing mermaid divs
        const mermaidDivs = document.querySelectorAll('div.mermaid');
        if (mermaidDivs.length === 0) return;

        const nodesToProcess = [];

        mermaidDivs.forEach(div => {
            const originalCode = div.getAttribute('data-original-code');
            if (originalCode) {
                // Restore original code and clear previous SVG
                div.textContent = originalCode;
                div.removeAttribute('data-processed'); // Clear mermaid marker if any
                nodesToProcess.push(div);
            }
        });

        if (nodesToProcess.length > 0) {
            try {
                await window.mermaid.run({
                    nodes: nodesToProcess
                });
            } catch (error) {
                console.error('Mermaid re-rendering failed:', error);
            }
        }
    }

    // Observe theme changes
    function observeThemeChanges() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.attributeName === 'class') {
                    // Debounce or just run? Theme change is rare, just run.
                    updateDiagramsTheme();
                }
            });
        });

        observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class']
        });
        console.log('Mermaid: Theme observer attached');
    }

    // Expose global function
    window.renderMermaid = renderMermaid;

    // Initial check (in case loaded directly, though mostly used dynamically)
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            init(getCurrentTheme());
            observeThemeChanges();
        });
    } else {
        init(getCurrentTheme());
        observeThemeChanges();
    }

})();
